;;; -*- mode: Lisp; Syntax: Common-Lisp; -*-
;;;
;;; Copyright (c) 2006 by the authors.
;;;
;;; See LICENCE for details.

(in-package :hu.dwim.perec)

;;(declaim-debug)

;;;; This file contains classes and methods for storing, filtering, mapping
;;;; results of SQL queries.
;;;;
;;;; TODO: filters are not lazy
;;;; TODO: scrolled-result-set should add an ORDER-BY clause to the query to make it deterministic


;;;
;;; Result-set
;;;

(defclass* result-set ()
  ())

(defgeneric open-result-set (type sql-query &optional sql-count-query)
  (:documentation "Returns a new result-set which is the result of the sql-query."))

(defgeneric close-result-set (result-set)
  (:documentation "Closes the result-set. After this operation the result-set cannot be accessed.")
  (:method (result-set)
           (values)))

(defgeneric revive-result-set! (result-set)
  (:documentation "Refreshes the result set to be valid in the current transaction.")
  (:method (result-set)
           (values)))

(defgeneric record-count-of (result-set)
  (:documentation "Returns the number of records in RESULT-SET.")
  (:method ((result-set abstract-container))
           (size result-set)))

(defgeneric records-of (result-set &optional start end)
  (:documentation "Returns records of RESULT-SET as a sequence from START index
 (inclusive, default is 0) to END index (exclusive, default is the number of records).")
  (:method :around (result-set &optional (start 0) end)
           (bind ((size (record-count-of result-set)))
             (unless end (setf end size))
             (unless (<= 0 start size) (error "Start index ~D out of range for result-set: ~A" start result-set))
             (unless (<= 0 end size) (error "End index ~D out of range for result-set: ~A" end result-set))
             (unless (<= start end) (error "Start index ~D is greater than end index ~D" start end))
             (if (= start end)
                 nil
                 (call-next-method result-set start end))))
  (:method ((result-set iteratable-container-mixin) &optional start end)
           (iter (for i from start below end)
                 (collect (nth-element result-set i) :result-type 'vector)))
  (:method ((result-set array-container) &optional start end)
           (iter (for i from start below end)
                 (collect (nth-element result-set i) :result-type 'vector))))

(defgeneric to-list (result &key flatp)
  (:documentation "Converts the result to a list.
If FLATP is true then the rows are flattened (useful when they contain only one column).")
  (:method ((result list) &key flatp)
           (if flatp (apply 'nconc result) result))
  (:method ((result array) &key flatp)
           (if flatp
               (iter (for element :in-vector result)
                     (appending (coerce element 'list)))
               (iter (for element :in-vector result)
                     (collect (coerce element 'list)))))
  (:method ((result contents-as-list-mixin) &key flatp)
           (to-list (contents result) :flatp flatp))
  (:method ((result contents-as-array-mixin) &key flatp)
           (to-list (contents result) :flatp flatp))
  (:method ((result iteratable-container-mixin) &key flatp)
           (iter (with iterator = (make-iterator result))
                 (while (current-element-p iterator))
                 (if flatp
                     (appending (coerce (current-element iterator) 'list))
                     (collect (coerce (current-element iterator) 'list)))
                 (move-forward iterator)))
  (:method ((result result-set) &key flatp)
           (if flatp
               (iter (for record :in-sequence (records-of result))
                     (appending (coerce record 'list)))
               (iter (for record :in-sequence (records-of result))
                     (collect (coerce record 'list)))))
  (:method ((result scroll) &key flatp) ; for testing only
           (iter outer ; (called from code generated by the debug compiler)

                 (for page from 0)
                 (for dummy first (first-page! result) then (next-page! result))
                 (while (= page (page result)))
                 (for elements = (elements result))
                 (while (> (length elements) 0))
                 (iter (for element in-sequence elements)
                       (in outer
                           (if flatp
                               (if (flatp result)
                                   (collect element)
                                   (appending (coerce element 'list)))
                               (if (flatp result)
                                   (collect (list element))
                                   (collect (coerce element 'list)))))))))

(defgeneric to-scroll (result-set &key flatp)
  (:documentation "Converts the result set to a scroll.")
  (:method ((result-set scroll) &key &allow-other-keys)
           result-set)
  (:method ((result-set result-set) &key flatp)
           (make-instance 'result-set-scroll :result-set result-set :flatp flatp)))

;;;----------------------------------------------------------------------------
;;; Scroll
;;;
(defclass* result-set-scroll (fixed-size-scroll result-set)
  ((inner-result-set :initarg :result-set)
   (page 0 :accessor page)
   (page-size 10 :accessor page-size)
   (flatp #f :accessor flatp)))

(defmethod element-count ((scroll result-set-scroll))
  (record-count-of (inner-result-set-of scroll)))

(defmethod page-count ((scroll result-set-scroll))
  (values (ceiling (/ (element-count scroll) (page-size scroll)))))

(defmethod elements ((scroll result-set-scroll))
  (bind ((inner (inner-result-set-of scroll))
         (start (* (page scroll) (page-size scroll)))
         (end (min (+ start (page-size scroll)) (record-count-of inner)))
         (records (when (> end start) (records-of inner start end))))
    (when (flatp scroll)
      (assert (or (zerop (length records)) (= 1 (length (elt records 0)))))
      (setf records (map 'vector [elt !1 0] records)))
    records))

(defmethod revive-scroll! ((scroll result-set-scroll))
  (revive-result-set! scroll))

(defmethod revive-result-set! ((result-set result-set-scroll))
  (revive-result-set! (inner-result-set-of result-set)))

(defmethod close-result-set ((result-set result-set-scroll))
  (close-result-set (inner-result-set-of result-set)))

;;;----------------------------------------------------------------------------
;;; Transformers

;;;
;;; Base class for transformers
;;;
(defclass* result-set-transformer (result-set)
  ((inner :type result-set)))

(defmethod close-result-set ((result-set result-set-transformer))
  (close-result-set (inner-of result-set)))

(defmethod revive-result-set! ((result-set result-set-transformer))
  (revive-result-set! (inner-of result-set))
  (update-contents! result-set))

(defgeneric update-contents! (result-set)
  (:method (result-set)
           (values)))

;;;
;;; Limited result-set
;;;
(defclass* limited-result-set (result-set-transformer)
  ((offset :type integer)
   (limit :type (or null integer))))

(defun make-limited-result-set (result-set offset limit)
  (make-instance 'limited-result-set :inner result-set :offset (or offset 0) :limit limit))

(defmethod record-count-of ((result-set limited-result-set))
  (bind ((count (record-count-of (inner-of result-set)))
         (start (offset-of result-set))
         (end (if (limit-of result-set)
                  (min (+ start (limit-of result-set)) count)
                  count)))
    (if (< start end) (- end start) 0)))

(defmethod records-of ((result-set limited-result-set) &optional start end)
  (with-slots (inner offset) result-set
    (records-of inner (+ offset start) (+ offset end))))


;;;
;;; Ordered result-set
;;;
;;; TODO: lazyness

(defclass* ordered-result-set (vector-container result-set-transformer)
  ((lessp :type function)))

(defun make-ordered-result-set (result-set lessp)
  (bind ((instance (make-instance 'ordered-result-set :inner result-set :lessp lessp)))
    (update-contents! instance)
    instance))

(defmethod update-contents! ((result-set ordered-result-set))
  (with-slots (contents inner lessp) result-set
    (setf contents (sort (records-of inner) lessp)))
  (values))

;;;
;;; Filtered result-set
;;;
;;; TODO: lazyness

(defclass* filtered-result-set (vector-container result-set-transformer)
  ((predicate :type function)))

(defun make-filtered-result-set (result-set predicate)
  (bind ((instance (make-instance 'filtered-result-set :inner result-set :predicate predicate)))
    (update-contents! instance)
    instance))

(defmethod update-contents! ((result-set filtered-result-set))
  (with-slots (contents inner predicate) result-set
    (bind ((records (records-of inner)))
      (setf contents
            (aprog1 (make-array (length records) :adjustable #t :fill-pointer 0)
              (iter (for record in-sequence records)
                    (when (funcall predicate record)
                      (vector-push record it)))))))
  (values))

;;;
;;; Grouping
;;;

(defclass* grouped-result-set (vector-container result-set-transformer)
  ((group-by-fn :type function)
   (init-fn :type function)
   (collect-fn :type function)
   (map-fn :type function)))

(defun make-grouped-result-set (result-set group-by-fn init-fn collect-fn map-fn)
  (bind ((instance (make-instance 'grouped-result-set :inner result-set :group-by-fn group-by-fn
                                  :init-fn init-fn :collect-fn collect-fn :map-fn map-fn)))
    (update-contents! instance)
    instance))

(defmethod update-contents! ((result-set grouped-result-set))
  (with-slots (contents inner group-by-fn init-fn collect-fn map-fn) result-set
    (bind ((ht (make-hash-table :test 'equal)))
      (labels ((aggregate (key record)
                 (bind ((acc (gethash key ht (funcall init-fn)))
                        (new-acc (funcall collect-fn record acc)))
                   (setf (gethash key ht) new-acc))))
        (iter (for record in-sequence (records-of inner))
              (for key = (funcall group-by-fn record))
              (aggregate key record))
        (when (= (hash-table-count ht) 0) ;; input result-set is empty
          (setf (gethash nil ht) (funcall init-fn)))
        (setf contents
              (aprog1 (make-array (hash-table-count ht))
                (iter (for i :from 0)
                      (for (key acc) :in-hashtable ht)
                      (setf (aref it i) (funcall map-fn acc)))))))))

;;;
;;; Unique filtered result-set
;;;
;;; TODO: lazyness
(defclass* unique-result-set (vector-container result-set-transformer)
  ((test-fn :type function)))

(defun make-unique-result-set (result-set &key (test #'equal))
  (bind ((instance (make-instance 'unique-result-set :inner result-set :test-fn test)))
    (update-contents! instance)
    instance))

(defmethod update-contents! ((result-set unique-result-set))
  (with-slots (contents inner test-fn) result-set
    (bind ((ht (make-hash-table :test test-fn)))
      (iter (for record in-sequence (records-of inner))
            (setf (gethash record ht) #t))
      (setf contents
            (aprog1 (make-array (hash-table-count ht))
              (iter (for i :from 0)
                    (for (key acc) :in-hashtable ht)
                    (setf (aref it i) key)))))))

;;;
;;; Mapped result-set
;;;
(defclass* mapped-result-set (result-set-transformer)
  ((map-fn :type function)))

(defun make-mapped-result-set (result-set map-fn)
  (make-instance 'mapped-result-set :inner result-set :map-fn map-fn))

(defmethod record-count-of ((result-set mapped-result-set))
  (record-count-of (inner-of result-set)))

(defmethod records-of ((result-set mapped-result-set) &optional start end)
  (with-slots (contents inner map-fn) result-set
    (bind ((records (records-of inner start end)))
      (aprog1 (make-array (length records))
        (iter (for i from 0)
              (for record in-sequence records)
              (setf (aref it i) (funcall map-fn record)))))))

;;;----------------------------------------------------------------------------
;;; Sources

;;;
;;; Vector result-set
;;;
(defclass* vector-result-set (vector-container result-set)
  ())

(defun make-vector-result-set (vector)
  (make-instance 'vector-result-set :contents vector))

(defmethod revive-result-set! ((result-set vector-result-set))
  (iterate-elements result-set
                    (lambda (record)
                      (map nil
                           [when (persistent-object-p !1) (revive-instance !1)]
                           record))))

;;;
;;; List result-set
;;;
(defclass* list-result-set (vector-container result-set)
  ())

(defun make-list-result-set (list)
  (aprog1 (make-instance 'list-result-set)
    ;; TODO coerce to vector of vectors
    (setf (contents it) (coerce list 'vector))))

(defmethod revive-result-set! ((result-set list-result-set))
  (iterate-elements result-set
                    (lambda (record)
                      (map nil
                           [when (persistent-object-p !1) (revive-instance !1)]
                           record))))


;;;
;;; Simple SQL result set
;;;
(defclass* simple-result-set (vector-container result-set)
  ((sql-query))
  (:documentation "Retrieves all records at once as a vector of vectors."))

(defmethod open-result-set ((type (eql 'list)) sql-query &optional sql-count-query)
  (declare (ignore sql-count-query))
  (bind ((instance (make-instance 'simple-result-set :sql-query sql-query)))
    (revive-result-set! instance)
    instance))

(defmethod revive-result-set! ((result-set simple-result-set))
  (setf (contents result-set) (execute (funcall (sql-query-of result-set) nil nil)
                                       :result-type 'vector)))

;;;
;;; Scrolled SQL result set
;;;
(defclass* scrolled-result-set (result-set)
  ((record-count :type integer)
   (sql-query)
   (sql-count-query))
  (:documentation "Retrieves the records using OFFSET and LIMIT in the SQL query."))

(defmethod open-result-set ((type (eql 'scroll)) sql-query &optional sql-count-query)
  (assert sql-count-query)
  (bind ((instance (make-instance 'scrolled-result-set
                                  :sql-query sql-query
                                  :sql-count-query sql-count-query)))
    (revive-result-set! instance)
    instance))

(defmethod revive-result-set! ((result-set scrolled-result-set))
  (with-slots (sql-count-query) result-set
    (setf (record-count-of result-set) (first-elt (first-elt (execute sql-count-query)))))
  (values))

(defmethod records-of ((result-set scrolled-result-set) &optional start end)
  #+nil
  (setf (hu.dwim.rdbms::offset-of (sql-query-of result-set)) start
        (hu.dwim.rdbms::limit-of (sql-query-of result-set)) (- end start))
  (execute (funcall (sql-query-of result-set) start (- end start))
           :result-type 'vector
           :start-row start
           :row-limit (- end start)))

